---
title: Reference
description: diogenic language reference
---

Diogenic language reference

## Introduction

Diogenic is a language designed to write DSP patches as
S-expressions. It borrows a lot of its syntax from
[Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language)).

## Functions

Functions in diogenic are similar to macros in the way they're
implemented; function names are erased from the final instruction
sequence during compilation.

```scm
(defun my-saturation (in)
  (tanh (* 2.0 (foldback 0.75 in))))

(+ (my-saturation (sine! 220.0))
   (my-saturation (sine! 440.0)))
```

## Macros

### `->`

Pipes the `n`th child to the first argument of the `n+1`th child.
Useful for long, sequential chains of DSP calls.

```scm
(-> (sine! 220.0)
    (cos)
    (tan)
    (foldback :threshold 0.8))

; compiles down to:
(foldback (tan (cos (sine! 220.0))) :threshold 0.8)
```

## Special Forms

Special forms are expressions that take some unevaluated arguments.

### `let`

Takes name, value couples as reusable bindings

```scm
(let
  (freq 440.0
   threshold (+ 0.5 (* 0.1 (sine! :freq 0.2))))
  (foldback threshold freq))
```

Values defined in the bindings section may reference previously
bound variables:

```scm
(let
  (mod-freq 220.0
   mod-phase PI
   mod (sine! mod-freq mod-phase))
  (...))
```

### `map`

Linearly rescales an input signal from a specified range
to another.

```scm
(map (sine! :freq 0.2) ; input signal
     -1.0 1.0 ; input range
     0.0 0.6) ; output range
```

`map` expects literal numbers for the ranges.

## Built-in devices

Pure devices only manipulate the diogenic VM stack. Impure devices
may also manipulate the state, a persistent f32 array. These are
marked by and exclamation mark (`!`).

::include{file="./_docs.md"}
